package io.swagger.configuration;

import com.oracle.javafx.jmx.json.JSONException;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.TimeZone;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.HttpsURLConnection;
import org.apache.commons.codec.binary.Hex;
import org.json.JSONObject;
import org.springframework.http.HttpMethod;

public class GDAXAuthorizer {
  private final String secret;
  private String cbAccessKey;
  private String timestamp;
  private String cbAccessPassphrase;

  public static JSONObject makeGDAXRequest(Map<String, String> headermap, JSONObject body, HttpMethod method, String route)
      throws IOException, JSONException, URISyntaxException {
    String query = "https://api-public.sandbox.gdax.com";
    String json = body.toString();
    URL url = new URL(query + route);
    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
    System.out.println(method.toString());
    conn.setRequestMethod(method.toString());
    System.out.println(conn.getRequestMethod());
    conn.setConnectTimeout(5000);
    conn.setRequestProperty("Content-Type", "application/json");
    headermap.putAll(getAuthHeaders(body, method, route)); //Make sure we add these authorization headers
    for (Map.Entry<String, String> header : headermap.entrySet()) { //Add all of the headers from our map
      conn.setRequestProperty(header.getKey(), header.getValue());
    }
    conn.setDoOutput(true);
    conn.setDoInput(true);
    OutputStream os = conn.getOutputStream();
    os.write(json.getBytes("UTF-8"));
    os.close();

    // read the response
    InputStream in = new BufferedInputStream(conn.getInputStream());
    String result = in.toString();
    JSONObject res = new JSONObject(result);

    in.close();
    conn.disconnect();

    return res;
  }

  public static Map<String, String> getAuthHeaders(JSONObject body, HttpMethod method, String route) {
    Map<String, String> headers = new HashMap<>();
    GDAXAuthorizer auth = new GDAXAuthorizer(new File("src/main/resources/gdax.keystore"));
    headers.put("CB-ACCESS-TIMESTAMP", auth.getCBAccessTimestamp()); //Put timestamp first so we calculate a fresh one.
    headers.put("CB-ACCESS-KEY", auth.getCBAccessKey());
    headers.put("CB-ACCESS-SIGN", auth.getCBSignature(body.toString(), method.toString(), route));
    headers.put("CB-ACCESS-PASSPHRASE", auth.getCBAccessPassphrase());

    return headers;
  }

  public GDAXAuthorizer(File gdaxfile) {
    Scanner fi = null;
    try {
      fi = new Scanner(gdaxfile);
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    }
    cbAccessKey = fi.nextLine();
    cbAccessPassphrase = fi.nextLine();
    secret = fi.nextLine();
  }

  private String getCBSignature(String gdaxRequestBody, String method, String requestPath) {
    /*
    like this but in Java
    function sign(bodyvar){
    var crypto = require('crypto-js');

var secret = 'UnUebsUpYTG+pl6VU7pD1US1GxFkmupok5xE4Y9RZ+u0YPrzJlamzxyrur5SgnZHHiL55uR9j+xmqF6qlRmZYA==';

var timestamp = Date.now() / 1000;
var requestPath = 'deposits/payment-method';

var body = JSON.stringify(bodyvar);

var method = 'POST';

// create the prehash string by concatenating required parts
var what = timestamp + method + requestPath + body;

// decode the base64 secret
var key = Buffer(secret, 'base64');

// create a sha256 hmac with the secret
var hmac = crypto.HmacSHA256(what.toString(), key);

// sign the require message with the hmac
// and finally base64 encode the result
return hmac.update(what).digest('base64');
}

pm.environment.set("timestampHeader", Date.now()/1000);
pm.environment.set("sig", sign({
    "amount": 10.00,
    "currency": "USD",
    "payment_method_id": "bc677162-d934-5f1a-968c-a496b1c1270b"
}));
     */
    System.out.println(timestamp + method + requestPath + gdaxRequestBody);
    /*
    The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the
    prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode
    the output. The timestamp value is the same as the CB-ACCESS-TIMESTAMP header.
     */
    String signature = sign(timestamp + method + requestPath + gdaxRequestBody);
    return signature;
  }

  private String sign(String data) {

    try {
      Mac hmac = Mac.getInstance("HmacSHA256");
      SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256");
      hmac.init(secret_key);
      return new String(Hex.encodeHex(hmac.doFinal(data.getBytes("UTF-8"))));
    } catch (Exception e) {
      throw new RuntimeException(e);
    }

  }

  private String getCBAccessKey() {
    return cbAccessKey;
  }

  private String getCBAccessPassphrase() {
    return cbAccessPassphrase;
  }

  private String getCBAccessTimestamp() {
    updateTimestamp();
    return this.timestamp;
  }

  private void updateTimestamp() {
    TimeZone tz = TimeZone.getTimeZone("UTC");
    DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); // Quoted "Z" to indicate UTC, no timezone offset
    df.setTimeZone(tz);
    timestamp = df.format(new Date());
  }
}
